---
title: "Converting Facebook Mobility Datasets Identified by Quadkeys into Raster Images"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Converting Facebook Mobility Datasets Identified by Quadkeys into Raster Images}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  warning = FALSE,
  message = FALSE,
  comment = "#>"
)
```

```{r setup, echo = FALSE, message = FALSE, warning=FALSE}
library(quadkeyr)
library(sf)
library(dplyr)
library(tidyr)
library(ggplot2)
library(rnaturalearth)
library(stars)

```

> Please, visit the [README](https://fernandez-lab-wsu.github.io/quadkeyr/) 
> for general information about this package

This section focuses on creating a raster from QuadKey data formatted as 
provided by [Facebook Mobility data](https://dataforgood.facebook.com/). 
If you want to convert other QuadKey-identified datasets you can read
[the previous vignette.]( https://fernandez-lab-wsu.github.io/quadkeyr/articles/B-from_quadkey_identified_data_to_raster.html)

Facebook mobility data for each location and level of detail is stored in
a separate `csv` file for each day and time.

### 1. read all the `csv` files from a folder and format them

All this files are for the same area and level of detail, but dates and times
change.

`read_fb_mobility_files` produce a warning in case there are days or times missing.

```{r read}

files <- read_fb_mobility_files(path_to_csvs = paste0(system.file("extdata",
                                                           package = "quadkeyr"), "/"),
                                colnames = c("lat", "lon", 
                                             "quadkey", "date_time", 
                                             "n_crisis", "percent_change"),
                                coltypes = list(
                                  lat = 'd',
                                  lon = 'd',
                                  quadkey = 'c',
                                  date_time = 'T',
                                  n_crisis = 'c',
                                  percent_change = 'c')) 

files

```

### 2. Convert the QuadKey grid to latitude/longitude coordinates

Even if these files correspond to the same area of analysis, they can vary in 
the number of QuadKeys that are reported.

That is why we select from all the files all the QuadKeys that have data at 
least once and convert them to coordinates.

```{r}

quadkeys <-  unique(files$quadkey)

qtll <- quadkey_to_latlong(quadkeys = quadkeys)
qtll

```


Let's plot the QuadKey grid.

Keep in mind that in `files` I have data for multiple days and hours, and
in 

```{r echo= FALSE}

ggplot() + 
  geom_sf(data = ne_countries(returnclass = 'sf'),
          fill = 'beige') +
  geom_sf(data = qtll, alpha = 0.5, size = 0.5) +
  coord_sf(xlim = c(-58.65, -58.45),
            ylim = c(-34.65, -34.45), expand = FALSE) +
  theme_minimal()  +
  theme(panel.background = element_rect(fill = "lightblue"),
        panel.ontop = FALSE,
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank()) +
  ylab("Latitude") + 
  xlab("Longitude")
```

### 3. Complete the grid 

Some of the QuadKeys are missing, we can't consider this a regular grid. 

In order to create the polygons, let's complete the grid. Pay attention that
the output is a list with 3 elements: `data`, `num_rows` and `num_cols`.

```{r rgc}
regular_grid <- regular_qk_grid(qtll)
regular_grid
```

 `num_cols` and `num_rows` refer to the number of columns and rows, we will use
 this data to create the raster.
 
The original 150-point grid now has one point per row and cell, resulting in a 
complete grid of 369 points, as depicted in the plot. The additional points are
highlighted in orange:

```{r echo = FALSE}

ggplot() + 
  geom_sf(data = ne_countries(returnclass = 'sf'),
          fill = 'beige') +
  geom_sf(data = regular_grid$data, alpha = 0.5, size = 0.5, color = 'orange') +
  geom_sf(data = qtll, alpha = 0.5, size = 0.5) +
  coord_sf(xlim = c(-58.65, -58.45),
            ylim = c(-34.65, -34.45), expand = FALSE) +
  theme_minimal()  +
  theme(panel.background = element_rect(fill = "lightblue"),
        panel.ontop = FALSE,
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank()) +
  ylab("Latitude") + 
  xlab("Longitude")
```

### 4. Create the polygons


```{r}
# Now we can transform the quadkeys into polygons
polygrid <- grid_to_polygon(regular_grid$data)
polygrid
```


```{r echo = FALSE}
ggplot() + 
  geom_sf(data = ne_countries(returnclass = 'sf'),
          fill = 'beige') +
  geom_sf(data = polygrid, alpha = 0.5, size = 0.1, 
          color = 'red', alpha = 0.5) +
  coord_sf(xlim = c(-58.65, -58.45),
            ylim = c(-34.65, -34.45), expand = TRUE) +
  theme_minimal()  +
  theme(panel.background = element_rect(fill = "lightblue"),
        panel.ontop = FALSE,
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank()) +
  ylab("Latitude") + 
  xlab("Longitude")
```

Once I have the regular grid of QuadKeys for the bounding box and level of detail,
I combined the information with the data provided. I can select the variables
that will be part of the analysis and also create new variables if needed.

```{r}
polyvar <- files |>
            dplyr::inner_join(polygrid, by = 'quadkey') 

head(polyvar)
```


### 5. Create the rasters for the variables and data involved.

The rasters are going to be created automatically for each day and time reported.
Each raster will be created as `<filename>_<date>_<time>.tif`.
The function `polygon_to_raster` will work even if there are some days and times
missing.

```{r eval = FALSE, include = TRUE}

polygon_to_raster(data = polyvar,
                  nx = regular_grid$num_cols +1 ,
                  ny = regular_grid$num_rows +1 ,
                  template = polyvar,
                  var = 'percent_change',
                  filename = 'cityA',
                  path = "../inst/extdata/"
                  )

```


Let's plot one of the rasters, `"cityA_2020-04-15_8.tif"`.
As you can see, the overlapping with the polygon grid is perfect:

```{r echo=FALSE}

filename <- "cityA_2020-04-15_8.tif"
output_raster <-  stars::read_stars(system.file("extdata",
                                                filename, 
                                                package = "quadkeyr"))

ggplot() + 
  geom_sf(data = ne_countries(returnclass = 'sf'),
          fill = 'beige') +
  geom_stars(data = output_raster) +
  ggplot2::scale_fill_viridis_c(option = "C",
                        na.value = "transparent",
                        name = "Percent change (%)") +
  geom_sf(data = polygrid, alpha = 0.5, 
          size = 0.1, color = 'red', alpha = 0.5) +
  coord_sf(xlim = c(-58.65, -58.45),
            ylim = c(-34.65, -34.45), expand = TRUE) +
  theme_minimal()  +
  theme(panel.background = element_rect(fill = "lightblue"),
        panel.ontop = FALSE,
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank()) +
  ggtitle(filename) +
  ylab("Latitude") + 
  xlab("Longitude")

```


