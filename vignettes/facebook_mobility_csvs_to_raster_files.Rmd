---
title: "Converting Facebook Mobility QuadKey-identified Datasets into Raster Files"
output:
  html_document:
    number_sections: true
vignette: >
  %\VignetteIndexEntry{Converting Facebook Mobility QuadKey-identified Datasets into Raster Files}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  warning = FALSE,
  message = FALSE,
  comment = "#>"
)
```

```{r setup, echo = FALSE, message = FALSE, warning=FALSE}
library(quadkeyr)
library(sf)
library(dplyr)
library(tidyr)
library(ggplot2)
library(rnaturalearth)
library(stars)

```

> Please, visit the [README](https://fernandez-lab-wsu.github.io/quadkeyr/) 
> for general information about this package

This section focuses on creating a raster from QuadKey data formatted as 
provided by [Facebook Mobility data](https://dataforgood.facebook.com/). 
If you want to convert other QuadKey-identified datasets 
you can read
[the previous vignette.](https://fernandez-lab-wsu.github.io/quadkeyr/articles/quadkey_identified_data_to_raster.html)

Facebook mobility data for each location and zoom level is stored in
a separate `csv` file for each day and time.

## Basic workflow


```{r w3, echo = FALSE, out.width= "90%", fig.align='center'}
knitr::include_graphics("../man/figures/workflow_facebook.png")
```


### Reading and formatting multiple `csv` Files

- All this files are for the same area and zoom level, but dates and hours will
change.

- `read_fb_mobility_files` produce a warning in case
there are days or times missing.

```{r read}

files <- read_fb_mobility_files(path_to_csvs = paste0(system.file("extdata",
                                              package = "quadkeyr"), "/"),
                                colnames = c("lat", "lon", 
                                             "quadkey", "date_time", 
                                             "n_crisis", "percent_change"),
                                coltypes = list(
                                  lat = 'd',
                                  lon = 'd',
                                  quadkey = 'c',
                                  date_time = 'T',
                                  n_crisis = 'c',
                                  percent_change = 'c')) 

files

```


### Create a grid and merge

This function generates a `sf POLYGON data.frame` with a
`quadkey` and `geometry` column.

You might be wondering why we're not using
the function we've already created, 
`add_regular_polygon_grid()`, 
which adds a column with QuadKey polygons,
creating a regular grid, to an existing `data.frame`

There are two reasons for why we're using a different approach:

  1 - The `read_fb_mobility_files` output
contains multiple datasets for the same area
with the almost the same QuadKeys reported.
Using a function that calculates each QuadKey by row
would unnecessarily duplicate calculations.

  2 - When you receive Facebook mobility data,
  you might not always get exactly the same QuadKeys in all the files,
  even if they all report the same area. 
  This is especially important considering
  that you may be receiving new files in the future.
  
That's why we create an `sf POLYGON` geometry data.frame,
retaining all the QuadKey polygons within the area of analysis,
and then proceed to join the results.

If creating the regular grid using the bounding box of the provided
QuadKeys may not work for your case, you can directly create the grid 
for the full area of analysis using the `create_qk_grid()` function.
Read the [the previous vignette](https://fernandez-lab-wsu.github.io/quadkeyr/articles/quadkey_identified_data_to_raster.html)
to learn more about this function.


```{r grid}

regular_grid <- get_regular_polygon_grid(data = files)
regular_grid$data

```

```{r reg_grid, out.width= "90%", fig.align='center'}
ggplot() +
  geom_sf(data = regular_grid$data, 
          color = 'red', 
          linewidth = 1.5, 
          fill = NA) + 
  theme_minimal()
```

And later, we merge it with the `files` dataset.
We've chosen to use an `dplyr::inner_join()`
as it is the fastest join method (cite)
and will retain only the polygons reported in the files.

```{r}

files_polygons <- files |> 
                  dplyr::inner_join(regular_grid$data, 
                          by = c("quadkey"))

files_polygons
```

Now that we have the polygons, let's create the raster files.

```{r rasterfiles}
# Generate the raster files                       
polygon_to_raster(data = files_polygons,
                  nx = regular_grid$num_cols+1,
                  ny = regular_grid$num_rows+1,
                  template = files_polygons,
                  var = 'percent_change',
                  filename = 'cityA',
                  path = paste0( system.file("extdata", 
                                             package = "quadkeyr"),
                                 "/"))
```

```{r qkgrid, out.width= "90%", fig.align='center'}
raster <- read_stars(paste0(system.file("extdata", 
                                        package = "quadkeyr"),
                                 "/cityA_2020-04-15_16.tif"))  

# More about plotting: 
# https://r-spatial.github.io/stars/reference/geom_stars.html
ggplot() +
  geom_stars(data = raster) +
  coord_equal()  +
    theme_void() +
  scale_fill_viridis_c(na.value = "transparent")+
    scale_x_discrete(expand=c(0,0))+
    scale_y_discrete(expand=c(0,0))
  
```


## Advanced use

We will work with the output of the `read_fb_mobility_files` function, 
the same that we have already used in the basic workflow.

```{r}
files
```


### Convert the QuadKey grid to latitude/longitude coordinates

Even if these files correspond to the same area of analysis, 
they can vary in the number of QuadKeys that are reported.

That is why we select from all the files all
the QuadKeys that have data at 
least once and convert them to
a `sf POINT data.frame` using `quadkey_to_latlong`

```{r}

# I get only the QuadKeys repeated in all the days and hours reported
quadkeys <-  unique(files$quadkey)

qtll <- quadkey_to_latlong(quadkeys = quadkeys)
qtll

```


Let's plot the QuadKey grid.


```{r echo= FALSE}

ggplot() + 
  geom_sf(data = ne_countries(returnclass = 'sf'),
          fill = 'beige') +
  geom_sf(data = qtll, alpha = 0.5, size = 0.5) +
  coord_sf(xlim = c(-58.65, -58.45),
            ylim = c(-34.65, -34.45), expand = FALSE) +
  theme_minimal()  +
  theme(panel.background = element_rect(fill = "lightblue"),
        panel.ontop = FALSE,
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank()) +
  ylab("Latitude") + 
  xlab("Longitude")
```

### Complete the grid 

Some of the QuadKeys are missing, we can't consider this a regular grid. 

In order to create the polygons, let's complete the grid. Pay attention that
the output is a list with 3 elements: `data`, `num_rows` and `num_cols`.

```{r rgc}
regular_grid <- regular_qk_grid(qtll)
regular_grid
```

 `num_cols` and `num_rows` refer to the number of columns and rows,
 we will use this data to create the raster.
 
The original 150-point grid 
now has one point per row and cell,
resulting in a complete grid of 369 points,
as depicted in the plot.
The additional points are highlighted in orange:

```{r echo = FALSE}

ggplot() + 
  geom_sf(data = ne_countries(returnclass = 'sf'),
          fill = 'beige') +
  geom_sf(data = regular_grid$data, alpha = 0.5, size = 0.5, color = 'orange') +
  geom_sf(data = qtll, alpha = 0.5, size = 0.5) +
  coord_sf(xlim = c(-58.65, -58.45),
            ylim = c(-34.65, -34.45), expand = FALSE) +
  theme_minimal()  +
  theme(panel.background = element_rect(fill = "lightblue"),
        panel.ontop = FALSE,
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank()) +
  ylab("Latitude") + 
  xlab("Longitude")
```

### Create the polygons

S

```{r}
# Now we can transform the quadkeys into polygons
polygrid <- grid_to_polygon(regular_grid$data)
polygrid
```


```{r echo = FALSE}
ggplot() + 
  geom_sf(data = ne_countries(returnclass = 'sf'),
          fill = 'beige') +
  geom_sf(data = polygrid, size = 0.1, 
          color = 'red', alpha = 0.5) +
  coord_sf(xlim = c(-58.65, -58.45),
            ylim = c(-34.65, -34.45), expand = TRUE) +
  theme_minimal()  +
  theme(panel.background = element_rect(fill = "lightblue"),
        panel.ontop = FALSE,
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank()) +
  ylab("Latitude") + 
  xlab("Longitude")
```

Once I have the regular grid of QuadKeys for the bounding box and zoom level,
I combined the information with the data provided. I can select the variables
that will be part of the analysis and also create new variables if needed.

```{r}
polyvar <- files |>
            dplyr::inner_join(polygrid, by = 'quadkey') 

head(polyvar)
```


### Create the rasters for the variables and data involved.

The rasters are going to be created automatically for each day and time reported.
Each raster will be created as `<filename>_<date>_<time>.tif`.
The function `polygon_to_raster` will work even if there are some days and times
missing.

```{r eval = FALSE, include = TRUE}

polygon_to_raster(data = polyvar,
                  nx = regular_grid$num_cols +1 ,
                  ny = regular_grid$num_rows +1 ,
                  template = polyvar,
                  var = 'percent_change',
                  filename = 'cityA',
                  path = "../inst/extdata/"
                  )

```


Let's plot one of the rasters, `"cityA_2020-04-15_8.tif"`.
As you can see, the overlapping with the polygon grid is perfect:

```{r echo=FALSE}

filename <- "cityA_2020-04-15_16.tif"
output_raster <-  stars::read_stars(system.file("extdata",
                                                filename, 
                                                package = "quadkeyr"))

ggplot() + 
  geom_sf(data = ne_countries(returnclass = 'sf'),
          fill = 'beige') +
  geom_stars(data = output_raster) +
  ggplot2::scale_fill_viridis_c(option = "C",
                        na.value = "transparent",
                        name = "Percent change (%)") +
  geom_sf(data = polygrid, alpha = 0.5, 
          size = 0.1, color = 'red') +
  coord_sf(xlim = c(-58.65, -58.45),
            ylim = c(-34.65, -34.45), expand = TRUE) +
  theme_minimal()  +
  theme(panel.background = element_rect(fill = "lightblue"),
        panel.ontop = FALSE,
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank()) +
  ggtitle(filename) +
  ylab("Latitude") + 
  xlab("Longitude")

```


